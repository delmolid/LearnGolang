# NOTES D'APPRENTISSAGE GO

## 1. PACKAGE FMT - FORMATAGE ET AFFICHAGE

### Import
import "fmt"

### Fonctions principales d'affichage
- fmt.Print()    : Affiche sans saut de ligne
- fmt.Println()  : Affiche avec saut de ligne automatique + espaces entre arguments
- fmt.Printf()   : Affichage avec formatage personnalisé

### Verbes de formatage courants
%s - string (chaîne de caractères)
%d - int (entier décimal)
%f - float (nombre décimal)
%t - bool (booléen true/false)
%v - any (valeur par défaut)
%T - any (type de la variable)

### Autres fonctions utiles
- fmt.Sprintf() : Formatage sans affichage (retourne une string)
- fmt.Scan()    : Lecture d'entrée utilisateur

### Exemples
fmt.Println("Hello World")                    // Hello World
fmt.Printf("Je m'appelle %s\n", "Alice")     // Je m'appelle Alice
fmt.Printf("Age: %d ans\n", 25)              // Age: 25 ans

## 2. VARIABLES EN GO

### Déclaration avec var
var a = "initial"           // Type inféré
var b, c int = 1, 2        // Déclaration multiple avec type explicite
var d = true               // Booléen
var e int                  // Valeur zéro (0 pour int)

### Déclaration courte avec :=
f := "apple"               // Équivalent à var f = "apple"

### Valeurs zéro par défaut
- int: 0
- string: ""
- bool: false
- float: 0.0

## 2.1 CONSTANTES EN GO

### Déclaration de constantes
const s string = "constant"     // Constante typée
const n = 500000000            // Constante non typée (plus flexible)
const pi = 3.14159             // Constante numérique

### Constantes typées vs non typées
- Constante typée : const typedConst int = 42
- Constante non typée : const untypedConst = 42 (plus flexible)

### Caractéristiques des constantes
- IMMUTABLES : Ne peuvent jamais être modifiées
- ÉVALUÉES À LA COMPILATION : Valeurs calculées avant l'exécution
- EXPRESSIONS CONSTANTES : Peuvent être des calculs avec des valeurs constantes
- CONVERSION AUTOMATIQUE : Les constantes non typées s'adaptent au contexte

### Types de constantes possibles
- Booléens : const isActive = true
- Chaînes : const message = "Hello"
- Numériques : const pi = 3.14159
- Caractères : const letter = 'A'

### Avantages des constantes non typées
- Flexibilité avec différents types numériques
- Précision arbitraire dans les calculs
- Conversion automatique selon le contexte

### Exemples d'utilisation
const d = 3e20 / n                    // Calcul à la compilation
fmt.Println(int64(d))                 // Conversion vers int64
fmt.Println(math.Sin(n))              // Conversion automatique vers float64

### Notation scientifique
3e20 = 3 × 10²⁰ = 300000000000000000000

## 3. TYPES DE DONNÉES DE BASE

### Strings
- Concaténation avec +
- Exemple: "go" + "lang" = "golang"

### Entiers et flottants
- Opérations arithmétiques: +, -, *, /
- Exemple: 1+1 = 2, 7.0/3.0 = 2.333...

### Booléens
- Opérateurs logiques:
  - && (ET logique)
  - || (OU logique)
  - !  (NON logique)
- Exemple: true && false = false

## 3.1 TABLEAUX (ARRAYS) EN GO

### Caractéristiques des tableaux
- TAILLE FIXE : Définie à la compilation
- TYPE HOMOGÈNE : Tous les éléments du même type
- INDEXATION : Commence à 0
- VALEURS PAR DÉFAUT : Zéro pour le type (0 pour int, "" pour string)

### 3.1.1 Déclaration de tableaux

### Déclaration avec taille explicite
var arr [5]int                        // Tableau de 5 entiers, initialisé à [0 0 0 0 0]

### Déclaration avec initialisation
arr := [5]int{1, 2, 3, 4, 5}         // Tableau avec valeurs initiales

### Taille automatique
arr := [...]int{1, 2, 3, 4, 5}       // Go calcule automatiquement la taille (5)

### 3.1.2 Opérations sur les tableaux

### Accès aux éléments
element := arr[2]                     // Récupère l'élément à l'index 2
arr[4] = 100                         // Modifie l'élément à l'index 4

### Longueur du tableau
length := len(arr)                    // Retourne la taille du tableau

### Parcours avec range (index et valeur)
for i, value := range arr {
    fmt.Printf("Index: %d, Valeur: %d\n", i, value)
}

### Parcours avec range (index seulement)
for i := range arr {
    fmt.Printf("Index: %d, Valeur: %d\n", i, arr[i])
}

### 3.1.3 Tableaux multidimensionnels

### Déclaration tableau 2D
var matrix [2][3]int                  // 2 lignes, 3 colonnes

### Initialisation avec boucles
for i := range 2 {
    for j := range 3 {
        matrix[i][j] = i + j          // Remplit avec la somme des indices
    }
}
// Résultat: [[0 1 2] [1 2 3]]

### Initialisation directe
matrix := [2][3]int{
    {1, 2, 3},                        // Première ligne
    {4, 5, 6},                        // Deuxième ligne
}

### Accès aux éléments 2D
element := matrix[1][2]               // Élément ligne 1, colonne 2
matrix[0][1] = 10                     // Modification d'un élément

### 3.1.4 Exemples pratiques

### Tableau simple
var scores [5]int
scores[0] = 95
scores[1] = 87
fmt.Println("Scores:", scores)        // [95 87 0 0 0]
fmt.Println("Longueur:", len(scores)) // 5

### Tableau avec valeurs
names := [3]string{"Alice", "Bob", "Charlie"}
for i, name := range names {
    fmt.Printf("Personne %d: %s\n", i+1, name)
}

### Matrice 2D pratique
var grid [3][3]int
// Remplir la diagonale
for i := range 3 {
    grid[i][i] = 1
}
fmt.Println("Matrice identité:", grid) // [[1 0 0] [0 1 0] [0 0 1]]

## 4. CONDITIONS ET STRUCTURES DE CONTRÔLE

### 4.1 Structure if/else if/else
if condition1 {
    // code si condition1 est vraie
} else if condition2 {
    // code si condition2 est vraie
} else {
    // code si aucune condition n'est vraie
}

### 4.2 Opérateurs de comparaison
- == : égal à
- != : différent de
- <  : inférieur à
- <= : inférieur ou égal à
- >  : supérieur à
- >= : supérieur ou égal à

### 4.3 Opérateurs logiques
- && : ET logique (AND)
- || : OU logique (OR)
- !  : NON logique (NOT)

### 4.4 if avec déclaration courte
if variable := valeur; condition {
    // variable est accessible ici seulement
}
// variable n'est plus accessible ici

### Exemple pratique
if num := 9; num < 0 {
    fmt.Println(num, "is negative")
} else if num < 10 {
    fmt.Println(num, "has 1 digit")
} else {
    fmt.Println(num, "has multiple digits")
}
// Sortie: 9 has 1 digit

### 4.5 Tests de parité et divisibilité
// Test de parité
if 7%2 == 0 {
    fmt.Println("7 is even")
} else {
    fmt.Println("7 is odd")  // Cette branche s'exécute
}

// Test de divisibilité
if 8%4 == 0 {
    fmt.Println("8 is divisible by 4")  // Cette condition est vraie
}

// Condition avec OR
if 8%2 == 0 || 7%2 == 0 {
    fmt.Println("either 8 or 7 are even")  // true || false = true
}

### Avantages de la déclaration courte dans if
- Portée limitée : la variable n'existe que dans le bloc if/else
- Code plus propre : évite la pollution de l'espace de noms
- Lisibilité : la logique est contenue dans le bloc

### 4.6 SWITCH - Alternative élégante à if/else

### Types de switch en Go
1. Switch classique : switch variable { case valeur: }
2. Switch conditionnel : switch { case condition: }
3. Type switch : switch variable.(type) { case type: }

### 4.6.1 Switch basique
i := 2
switch i {
case 1:
    fmt.Println("One")
case 2:
    fmt.Println("Two")    // Cette branche s'exécute
case 3:
    fmt.Println("Three")
}

### 4.6.2 Switch avec cases multiples
switch time.Now().Weekday() {
case time.Saturday, time.Sunday:
    fmt.Println("It's the weekend")
default:
    fmt.Println("It's weekday")
}

### 4.6.3 Switch sans expression (conditionnel)
t := time.Now()
switch {
case t.Hour() < 12:
    fmt.Println("It's before noon")
default:
    fmt.Println("It's after noon")
}
// Équivalent à switch true

### 4.6.4 Type Switch
whatAmI := func(i interface{}) {
    switch t := i.(type) {
    case bool:
        fmt.Println("I'm a bool")
    case int:
        fmt.Println("I'm a int")
    default:
        fmt.Printf("Don't Know type %T\n", t)
    }
}
whatAmI(true)   // I'm a bool
whatAmI(1)      // I'm a int
whatAmI("hey")  // Don't Know type string

### Caractéristiques du switch en Go
- PAS DE BREAK nécessaire (pas de fall-through automatique)
- Cases multiples : case a, b, c:
- Conditions dans les cases : case x > 10:
- default : cas par défaut optionnel
- Type switching unique à Go

### interface{} (type vide)
- Peut contenir n'importe quelle valeur
- Utilisé pour les fonctions génériques
- i.(type) : syntaxe pour obtenir le type concret

### Avantages du switch
- Plus lisible que de multiples if/else
- Performance optimisée
- Support natif des types
- Pas de risque d'oubli de break

## 5. BOUCLES ET STRUCTURES DE CONTRÔLE

### Types de boucles for en Go
Go n'a qu'un seul type de boucle : for (remplace while, do-while, etc.)

### 5.1 Boucle for basique (style while)
i := 1
for i <= 3 {
    fmt.Println(i)
    i = i + 1
}
// Sortie: 1, 2, 3

### 5.2 Boucle for style C
for j := 0; j < 3; j++ {
    fmt.Println("range", j)
}
// Structure: for initialisation; condition; post-statement
// Sortie: range 0, range 1, range 2

### 5.3 Boucle for range avec entier (Go 1.22+)
for i := range 3 {
    fmt.Println("range", i)
}
// range 3 génère les valeurs 0, 1, 2
// Plus concis que for i := 0; i < 3; i++

### 5.4 Boucle for range avec tableaux
arr := [3]int{10, 20, 30}

// Avec index et valeur
for i, value := range arr {
    fmt.Printf("arr[%d] = %d\n", i, value)
}

// Avec index seulement
for i := range arr {
    fmt.Printf("Index: %d\n", i)
}

// Avec valeur seulement (utiliser _)
for _, value := range arr {
    fmt.Printf("Valeur: %d\n", value)
}

### 5.5 Boucle infinie
for {
    fmt.Println("loop")
    break  // Sort de la boucle
}

### 5.6 Mots-clés de contrôle
- break    : Sort complètement de la boucle
- continue : Passe à l'itération suivante

### Exemple avec continue
for n := range 6 {
    if n%2 == 0 {  // Si n est pair
        continue   // Passe à l'itération suivante
    }
    fmt.Println(n) // Affiche seulement les impairs
}
// Sortie: 1, 3, 5

### Opérateur modulo %
- n % 2 : reste de la division de n par 2
- Si reste = 0 → nombre pair
- Si reste = 1 → nombre impair

## 6. FONCTIONS

### 6.1 Fonction main()
- Point d'entrée obligatoire du programme
- Pas de paramètres : func main()
- Pas de valeur de retour
- Le programme commence et se termine avec main()

### 6.2 Fonctions personnalisées
func nomFonction(paramètres) typeRetour {
    // corps de la fonction
    return valeur
}

### 6.3 Fonctions anonymes
variable := func(paramètres) typeRetour {
    // corps de la fonction
    return valeur
}

### Exemple de fonction avec retour
func Now() time.Time {
    return time.Now()
}

## 7. STRUCTURE D'UN PROGRAMME GO

```go
package main           // Déclaration du package
import "fmt"          // Import des packages nécessaires

func main() {         // Fonction principale
    // Code ici
}
```

## 8. BONNES PRATIQUES

- Utilisez := pour les nouvelles variables dans les fonctions
- Utilisez var pour les variables au niveau package
- Utilisez const pour les valeurs qui ne changent jamais
- Préférez les constantes non typées pour plus de flexibilité
- Groupez les constantes liées avec const ()
- Nommez les constantes en MAJUSCULES pour les exports publics
- Utilisez if avec déclaration courte pour limiter la portée des variables
- Préférez switch à de multiples if/else pour la lisibilité
- Utilisez Type Switch pour gérer différents types
- Utilisez l'opérateur modulo % pour tester la parité et la divisibilité
- Combinez les conditions avec &&, || et !
- Utilisez for range pour parcourir les tableaux
- Utilisez _ pour ignorer les valeurs non utilisées dans range
- Initialisez les tableaux avec [...] pour une taille automatique
- Utilisez des boucles imbriquées pour les tableaux multidimensionnels
- Utilisez continue pour filtrer dans les boucles
- Utilisez break pour sortir des boucles infinies
- Appelez vos fonctions depuis main() pour qu'elles s'exécutent
- fmt.Println() pour l'affichage simple
- fmt.Printf() pour l'affichage formaté
- Commentez votre code avec //

## 9. RESSOURCES D'APPRENTISSAGE

### Officielles
- Tour of Go: https://go.dev/tour/
- Go by Example: https://gobyexample.com/
- Documentation: https://go.dev/doc/

### Avec certificats
- Coursera: "Programming with Google Go Specialization"
- edX: "Introduction to Programming with Go"
- Pluralsight: "Go Path"

### Livres recommandés
- "The Go Programming Language" (Donovan & Kernighan)
- "Go in Action" (Manning)
- "Learning Go" (O'Reilly) 